Логика операций (в общих чертах)
•	push(x)
	1.	Проверяем: if (topIndex + 1 == capacity) — массив полный → вызываем resize(capacity * 2).
	2.	Увеличиваем topIndex на 1.
	3.	Записываем arr[topIndex] = x.
(Амортизированное время — O(1).)
	•	pop()
	1.	Если topIndex == -1 — стек пуст → ошибка/исключение.
	2.	Иначе уменьшаем topIndex на 1.
(O(1).)
	•	top()
	1.	Если topIndex == -1 — ошибка.
	2.	Возвращаем arr[topIndex].
(O(1).)
	•	empty() → topIndex == -1
	•	size() → topIndex + 1



class Stack {
    int* arr;
    int capacity;
    int topIndex;
};

int* arr;
	•	Это указатель на динамически выделенный массив int.
	•	В этом массиве мы храним элементы стека подряд: arr[0], arr[1], ....
	•	Используем динамический массив, чтобы память можно было выделять в рантайме (и при необходимости — увеличивать).

int capacity;
	•	Это текущая ёмкость (количество ячеек), которые выделены под arr.
	•	Например, capacity = 4 значит что arr — массив длины 4 (индексы 0..3).
	•	При заполнении всего массива обычно увеличиваем capacity (обычно в 2 раза) — это даёт амортизированную O(1)-вставку.

int topIndex;
	•	Это индекс вершины стека в массиве arr.
	•	Удобная конвенция: когда стек пуст — topIndex == -1.
	•	После первого push становится 0, второго — 1 и т.д.
	•	Количество элементов в стеке = topIndex + 1.



void hello(bool stop) {
    cout << "Начало функции\n";
    if (stop) {
        return; // просто выходим
    }
    cout << "Конец функции\n";
}

int main() {
    hello(true);   // выведет только "Начало функции"
    hello(false);  // выведет и "Начало функции", и "Конец функции"
}